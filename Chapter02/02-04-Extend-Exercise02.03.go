// 延伸習題
// 氣泡搜尋演算法:
// 對某切片中的資料進行排序, 做法是兩兩交換比對的元素, 用暴力法一直執行到全部排好為止。
// 這種排序技巧稱為氣泡排序法(bubble sort)
// 本題請勿使用 Go sort 套件

// 定義一切片集合, 其中有若干未經排序的數字。
// 先把切片印到主控台上, 將資料排序過後, 再印出排序後的集合。

// 排序步驟如下:

// 1. 走訪切片, 每次存取兩個相鄰的元素, 若後面的比較小, 就和前面的值對調, 並記錄做了對調動作。
// 2. 整個切片對調完一輪後, 如果上一輪有做過對調, 從頭重新再做一輪。
// 3. 等到整個切片已經由小到大排好, 不須再做任何對調時, 就結束排序。

// 提示: 要對調兩個變數的值
// nums[i], nums[i-1] = nums[i-1], nums[i]

// // 預期結果:
// 排序前: [5 8 2 4 0 1 3 7 9 6]
// 排序後: [0 1 2 3 4 5 6 7 8 9]

package main

import "fmt"

func main() {
	nums := []int {5, 8, 2, 4, 0, 1, 3, 7, 9, 6}
	fmt.Println("排序前:", nums)
	for swapped := true; swapped; {
		swapped = false
		for i := 1; i < len(nums); i++ {
			if nums[i-1] > nums[i] {
				nums[i], nums[i-1] = nums[i-1], nums[i]
				swapped = true
			}
		}
	}

	fmt.Println("排序後:", nums)
}